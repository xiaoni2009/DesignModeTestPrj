package cn.sort.shell;

import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;

/**
 * Created by xiaoni on 2019/9/9.
 * <p>
 * 希尔排序：是直接插入排序的升级版。
 * <p>
 * 直接插入排序：在排序的过程中，把数组的每一个元素按照大小关系，插入到前面有序区的对应位置。
 * 插入排序的平均时间复杂度是O（n^2）
 * <p>
 * 那么，怎样可以对插入排序算法做出优化呢？我们不妨从插入排序的两个特点入手：
 * <p>
 * 1.在大多数元素已经有序的情况下，插入排序的工作量较小
 * 这个结论很明显，如果一个数组大部分元素都有序，那么数组中的元素自然不需要频繁地进行比较和交换。
 * <p>
 * 2.在元素数量较少的情况下，插入排序的工作量较小
 * 这个结论更加显而易见，插入排序的工作量和n的平方成正比，如果n比较小，那么排序的工作量自然要小得多。
 * <p>
 * 如何对原始数组进行预处理呢？聪明的科学家想到了一种分组排序的方法，以此对数组进行一定的“粗略调整”。
 * <p>
 * 所谓分组，就是让元素两两一组，同组两个元素之间的跨度，都是数组总长度的一半，也就是跨度为4。
 * 接下来，我们让每组元素进行独立排序，排序方式用直接插入排序即可。由于每一组的元素数量很少，只有两个，所以插入排序的工作量很少。
 * <p>
 * 这样一来，仅仅经过几次简单的交换，数组整体的有序程度得到了显著提高，使得后续再进行直接插入排序的工作量大大减少。这种做法，可以理解为对原始数组的“粗略调整”。
 * <p>
 * 但是这样还不算完，我们可以进一步缩小分组跨度，重复上述工作。把跨度缩小为原先的一半，也就是跨度为2，重新对元素进行分组
 * <p>
 * 最后，我们把分组跨度进一步减小，让跨度为1，也就等同于做直接插入排序。经过之前的一系列粗略调整，直接插入排序的工作量减少了很多
 * <p>
 * 上面示例中所使用的分组跨度（4，2，1），被称为希尔排序的增量，增量的选择可以有很多种，我们在示例中所用的逐步折半的增量方法，
 * 是Donald Shell在发明希尔排序时提出的一种朴素方法，被称为希尔增量。
 * <p>
 * 希尔排序的最差时间复杂度是O（n^2），甚至比直接插入排序更慢，因为原来的数组可能使分组过程中没有元素被交换。
 * 对于这样的数组，希尔排序不但没有减少直接插入排序的工作量，反而白白增加了分组操作的成本。
 * <p>
 * 如何为希尔排序选择更有效的增量方式呢？
 * <p>
 * 为了保证分组粗调没有盲区，每一轮的增量需要彼此“互质”，也就是没有除1之外的公约数。
 * <p>
 * 于是，人们相继提出了很多种增量方式，其中最具代表性的是Hibbard增量和Sedgewick增量。
 * <p>
 * Hibbard的增量序列如下：
 * 1，3，7，15......
 * 通项公式 2^k-1
 * 利用此种增量方式的希尔排序，最坏时间复杂度是O（n^(3/2)）
 * <p>
 * Sedgewick的增量序列如下：
 * 1, 5, 19, 41, 109......
 * 通项公式 9*4^k - 9*2^k + 1 或者 4^k - 3*2^k + 1
 * 利用此种增量方式的希尔排序，最坏时间复杂度是O（n^(4/3)）
 * <p>
 * 关于这两种增量方式的时间复杂度，有些需要很复杂的数学证明，有些是人们的大致猜想，大家暂时不用纠结。
 * <p>
 * 希尔排序是一个不稳定排序，相同的数字的先后顺序有可能被交换。因为存在分组交换。
 */
@Slf4j
public class ShellSort {

    public static void sort(int[] array) {

        //希尔排序的增量
        int d = array.length;
        while (d > 1) {
            //使用希尔增量的方式，即每次折半
            d = d / 2;
            log.info("d = {}", d);

            for (int x = 0; x < d; x++) {
                log.info("###################x = {}", x);
                for (int i = x + d; i < array.length; i = i + d) {
                    log.info("i = {}", i);
                    int temp = array[i];
                    log.info("temp(array[i]) is: {}", temp);
                    int j;
                    //这里j=i-d=x开始，也就是j是前面的元素，i是后面的元素，当array[j] > temp=array[i]时，交换j和i
                    for (j = i - d; j >= 0 && array[j] > temp; j = j - d) {
                        log.info("j = {}", j);
                        log.info("before array[j+d] = {}", array[j + d]);
                        array[j + d] = array[j];
                        log.info("after array[j+d] = array[j] = {}", array[j]);
                    }
                    array[j + d] = temp;
                    log.info("last array[i] = {}", array[i]);
                    log.info("last array[j+d] = {}", array[j + d]);
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] array = {5, 3, 9, 12, 6, 1, 7, 2, 4, 11, 8, 10, 14, 16, 15};
        sort(array);
        log.info(Arrays.toString(array));
    }
}
